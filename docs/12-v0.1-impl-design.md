# v0.1 实现设计 — batch_extract_pages

> 状态：Draft
> 范围：从设计文档到代码的桥梁，覆盖模块划分、接口定义、集成点

> 更新说明（2026-02）：当前代码已在本设计基础上扩展到三模板与完整 RunManager/ArtifactStore；本稿保留 v0.1 设计语境。

## 1. 模块结构

```
src/task/
├── tool-context.ts          # ToolContext 接口定义
├── tool-actions.ts          # 6 个工具的核心逻辑（从 browser-mcp-server.ts 提取）
├── run-store.ts             # Map<string, RunState> + 状态机 + TTL 清理
├── templates/
│   └── batch-extract.ts     # executeBatchExtract 实现
└── index.ts                 # 导出
```

## 2. ToolContext 接口

```typescript
import type { SessionManager, Tab } from '../browser/index.js';
import type { CookieStore } from '../browser/CookieStore.js';
import type { ValidateUrlOptions } from '../utils/url-validator.js';
import type { TrustLevel } from '../mcp/browser-mcp-server.js';

export interface ToolContext {
  sessionManager: SessionManager;
  cookieStore?: CookieStore;
  urlOpts: ValidateUrlOptions;
  trustLevel: TrustLevel;

  /**
   * 解析 sessionId。
   * - MCP handler：走 defaultSession 逻辑（自动创建）
   * - 模板执行：直接返回 run 绑定的 sessionId
   */
  resolveSession(sessionId?: string): Promise<string>;

  /**
   * 获取指定 session 的活跃 tab。
   * 模板执行时通过显式 tabId 操作，不依赖 activeTabId。
   */
  getActiveTab(sessionId: string): Tab;

  /** 注入 cookie 到页面（CDP） */
  injectCookies(page: import('puppeteer-core').Page): Promise<void>;

  /** 从页面保存 cookie（CDP） */
  saveCookies(page: import('puppeteer-core').Page): Promise<void>;
}
```

### 2.1 两种 ToolContext 构造方式

**MCP handler 构造**（在 `browser-mcp-server.ts` 中）：
- `resolveSession` → 走现有 defaultSession 逻辑
- `getActiveTab` → 走 `sessionManager.getActiveTab()`

**模板执行构造**（在 `executeBatchExtract` 中）：
- `resolveSession` → 直接返回 run 绑定的 sessionId，忽略参数
- `getActiveTab` → 不使用（模板通过显式 tabId 操作指定 tab）

## 3. toolActions 函数签名

```typescript
// src/task/tool-actions.ts

export interface NavigateResult {
  success: boolean;
  partial: boolean;
  statusCode?: number;
  page: { url: string; title: string };
  dialog?: any;
}

export interface PageInfoResult {
  page: { url: string; title: string; type: string; summary: string };
  elements: any[];
  totalElements: number;
  truncated: boolean;
  regions: any[];
  intents: any[];
  stability?: any;
  pendingDialog?: any;
}

export interface PageContentResult {
  sections: any[];
  [key: string]: any;
}

export interface StabilityResult {
  stable: boolean;
  domStable: boolean;
  networkPending: number;
  loadState: string;
}

export interface CreateTabResult {
  tabId: string;
  url: string;
  partial: boolean;
}

/** 导航到 URL */
export async function navigate(
  ctx: ToolContext,
  sessionId: string,
  url: string
): Promise<NavigateResult>;

/** 等待页面稳定 */
export async function waitForStable(
  ctx: ToolContext,
  sessionId: string,
  tabId: string,
  opts?: { timeout?: number; quietMs?: number }
): Promise<StabilityResult>;

/** 获取页面语义信息 */
export async function getPageInfo(
  ctx: ToolContext,
  sessionId: string,
  tabId: string,
  opts?: { maxElements?: number; visibleOnly?: boolean }
): Promise<PageInfoResult>;

/** 提取页面文本内容 */
export async function getPageContent(
  ctx: ToolContext,
  sessionId: string,
  tabId: string,
  opts?: { maxLength?: number }
): Promise<PageContentResult>;

/** 创建新标签页 */
export async function createTab(
  ctx: ToolContext,
  sessionId: string,
  url?: string
): Promise<CreateTabResult>;

/** 关闭标签页 */
export async function closeTab(
  ctx: ToolContext,
  sessionId: string,
  tabId: string
): Promise<{ success: boolean }>;
```

### 3.1 关键设计决策

- **tabId 参数**：`waitForStable`、`getPageInfo`、`getPageContent` 接受显式 `tabId`，不依赖 `activeTabId`。这是并发 tab 场景的关键。
- **navigate 不接受 tabId**：因为 `navigate` 操作的是 active tab（与 MCP 行为一致）。模板中通过 `createTab` 创建 tab 后立即导航。
- **ctx 注入**：所有函数通过 ctx 获取依赖，不直接引用全局状态。

### 3.2 与 MCP handler 的集成

提取后，MCP handler 变为薄包装：

```typescript
// browser-mcp-server.ts 中的 navigate 工具
server.tool('navigate', '...', schema, safe(async ({ sessionId: rawSessionId, url }) => {
  const sid = await resolveSession(rawSessionId);
  const result = await toolActions.navigate(ctx, sid, url);
  return textResult(result);
}));
```

## 4. RunState 管理

```typescript
// src/task/run-store.ts

export type RunStatus = 'queued' | 'running' | 'succeeded' | 'failed' | 'partial_success';

export interface RunState {
  runId: string;
  templateId: string;
  status: RunStatus;
  createdAt: number;
  updatedAt: number;
  sessionId: string;
  ownsSession: boolean;        // true = run 结束后默认自动关闭 session（login_keep_session 例外）
  progress: { totalSteps: number; doneSteps: number };
  metrics: { elapsedMs: number };
  result?: any;                // 终态时填充
  error?: { errorCode: string; message: string; details?: any };
}

export class RunStore {
  private runs = new Map<string, RunState>();
  private cleanupInterval: NodeJS.Timeout;

  constructor(ttlMs = 30 * 60 * 1000) {
    // 每 5 分钟扫描一次，清理超过 TTL 的终态 run
    this.cleanupInterval = setInterval(() => this.cleanup(ttlMs), 5 * 60 * 1000);
  }

  create(templateId: string, sessionId: string, ownsSession: boolean, totalSteps: number): RunState;
  get(runId: string): RunState | undefined;
  transition(runId: string, status: RunStatus): void;
  updateProgress(runId: string, doneSteps: number): void;
  setResult(runId: string, result: any): void;
  setError(runId: string, error: RunState['error']): void;
  list(): RunState[];
  dispose(): void;

  private cleanup(ttlMs: number): void {
    // 清理 updatedAt + ttlMs < now 的终态 run
  }
}
```

### 4.1 状态机规则

```
queued → running → succeeded
                 → failed
                 → partial_success
```

终态不可逆。v0.1 不支持 `canceled`（无 `cancel_task_run` 工具）。

## 5. executeBatchExtract 实现

```typescript
// src/task/templates/batch-extract.ts

export interface BatchExtractInputs {
  urls: string[];
  extract?: {
    pageInfo?: boolean;    // 默认 true
    content?: boolean;     // 默认 true
    maxElements?: number;  // 默认 50
    maxContentLength?: number; // 默认 4000
  };
  concurrency?: number;    // 默认 3，上限 5
}

export interface BatchExtractItem {
  url: string;
  title?: string;
  pageType?: string;
  elementCount?: number;
  contentSections?: number;
  content?: any;
  success: boolean;
  error?: string;
}

export interface BatchExtractResult {
  summary: { total: number; succeeded: number; failed: number };
  items: BatchExtractItem[];
}

export async function executeBatchExtract(
  ctx: ToolContext,
  sessionId: string,
  inputs: BatchExtractInputs,
  onProgress: (done: number) => void
): Promise<BatchExtractResult>;
```

### 5.1 滑动窗口并发

```
实际并发 = min(inputs.concurrency ?? 3, 5, MAX_TABS_PER_SESSION - 已占用tab数)
```

实现方式：Promise 池（简单 semaphore）。

```typescript
async function slidingWindow<T>(
  items: T[],
  concurrency: number,
  fn: (item: T) => Promise<void>
): Promise<void> {
  let running = 0;
  let index = 0;
  return new Promise((resolve, reject) => {
    function next() {
      while (running < concurrency && index < items.length) {
        running++;
        const i = index++;
        fn(items[i]).then(() => { running--; next(); }).catch(reject);
      }
      if (running === 0 && index >= items.length) resolve();
    }
    next();
  });
}
```

### 5.2 单 URL 执行流程

```
1. createTab(ctx, sessionId, url)
2. waitForStable(ctx, sessionId, tabId, { timeout: 10000 })
3. if (extract.pageInfo) getPageInfo(ctx, sessionId, tabId, { maxElements, visibleOnly: false })
4. if (extract.content) getPageContent(ctx, sessionId, tabId, { maxLength })
5. closeTab(ctx, sessionId, tabId)
```

### 5.3 重试策略

- **触发条件**：`NAVIGATION_TIMEOUT` 或 `PAGE_CRASHED`
- **重试次数**：1 次
- **重试间隔**：立即（不退避）
- **重试方式**：关闭当前 tab，新建 tab 重新执行
- **其他错误**（如 `INVALID_PARAMETER`）：不重试，直接标记失败

### 5.4 partial_success 判定

```
成功比例 = succeeded / total
if (成功比例 >= 0.5) → partial_success
if (成功比例 < 0.5)  → failed
if (成功比例 === 1)   → succeeded
```

## 6. Sync/Async 模式实现

### 6.1 模式选择

```typescript
function resolveMode(mode: 'sync' | 'async' | 'auto' | undefined, urlCount: number): 'sync' | 'async' {
  if (mode === 'sync') return 'sync';
  if (mode === 'async') return 'async';
  // auto: URL <= 10 → sync, > 10 → async
  return urlCount <= 10 ? 'sync' : 'async';
}
```

### 6.2 sync 模式

`run_task_template` 直接 await `executeBatchExtract`，阻塞返回完整结果。

超时处理：sync 模式受 `options.timeoutMs`（默认 120s）约束。超时后：
- 已完成的 URL 结果保留
- 未完成的 URL 标记为失败
- 按 partial_success 规则判定终态

### 6.3 async 模式

`run_task_template` 立即返回 `{ runId, status: 'queued' }`，后台执行。客户端通过 `get_task_run` 轮询。

## 7. 3 个 MCP 工具注册

### 7.1 list_task_templates

```typescript
server.tool('list_task_templates', '列出可用任务模板', {}, async () => {
  return textResult({
    templates: [{
      templateId: 'batch_extract_pages',
      version: '1.0.0',
      name: '批量页面结构化采集',
      executionMode: 'auto',
      trustLevelSupport: ['local', 'remote'],
      limits: { maxUrls: 1000, maxConcurrency: 5 },
    }]
  });
});
```

### 7.2 run_task_template

```typescript
server.tool('run_task_template', '运行任务模板', {
  templateId: z.string(),
  templateVersion: z.string().optional(),
  sessionId: z.string().optional(),
  inputs: z.record(z.any()),
  options: z.object({
    timeoutMs: z.number().optional(),
    mode: z.enum(['sync', 'async', 'auto']).optional(),
  }).optional(),
}, async ({ templateId, sessionId, inputs, options }) => {
  // 1. 校验 templateId
  // 2. 校验 trustLevel
  // 3. 解析 mode
  // 4. 创建/复用 session
  // 5. 创建 RunState
  // 6. sync → await execute, async → 后台执行
  // 7. 返回结果
});
```

### 7.3 get_task_run

```typescript
server.tool('get_task_run', '查询任务运行状态', {
  runId: z.string(),
}, async ({ runId }) => {
  const run = runStore.get(runId);
  if (!run) throw error('RUN_NOT_FOUND');
  return textResult(run);
});
```

## 8. 集成点

### 8.1 browser-mcp-server.ts 改动

1. 提取 `saveCookiesFromPage`、`injectCookiesToPage` 到 `tool-actions.ts` 的内部辅助
2. 提取 6 个工具的核心逻辑为 `toolActions.*` 函数
3. MCP handler 改为调用 `toolActions.*`
4. 新增 3 个 MCP 工具注册（`list_task_templates`、`run_task_template`、`get_task_run`）
5. 构造 MCP 版 `ToolContext`（复用现有 `resolveSession`、`getActiveTab`）

### 8.2 不改动的部分

- SessionManager、PageEventTracker、语义引擎 — 不动
- 其他 22 个 MCP 工具 — 不动（v0.1 只提取 6 个）
- API 层、CLI 层 — 不动

## 9. 错误码扩展

在现有 `ErrorCode` 枚举中新增：

```typescript
export enum ErrorCode {
  // ... 现有
  TEMPLATE_NOT_FOUND = 'TEMPLATE_NOT_FOUND',
  TRUST_LEVEL_NOT_ALLOWED = 'TRUST_LEVEL_NOT_ALLOWED',
  RUN_NOT_FOUND = 'RUN_NOT_FOUND',
  RUN_TIMEOUT = 'RUN_TIMEOUT',
}
```
